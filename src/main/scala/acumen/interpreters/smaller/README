NOTES:

The test is in:
  src/test/scala/acumen/interpreters/smaller/SmallerInterpreterTest.scala

To run just this test from within sbt use:
> test-only acumen.interpreters.smaller.SmallerInterpreterTest

Typical interpreter structure

- ast    - acumen.AST *
- env    - standard.interpreter.Env *
           original.interpreter.Env
- store  - acumen.interpreters.imperative.Object (mutable)
           acumen.reference.original.interpreter.CStore (immutable)
- errors - acumen.Errors *
- eval   - 

o ::= self | n
x ::= o.n
e ::= constants, vectors, summations, ...
s ::= x'=e | x:=e | if e s else s end
    | create C(e*) | move ... | terminate ...
    | for ...
    | report error "..." // new construct
d ::= class C(x*) private s* end s* end
     
Syntactic sugar (taken care of by a preprocessor):
  - switch -> if + error
  - let x=e in s end -> s, and replace x everywhere with e
  - D ::= x | D'
  - Reducing higher derivatives to lower ones (cont. eq):
    D'=e -> y'=e, D=y, and replace D' everwhere with y'
    - Formally, D' is x'(n+1), and with notation D is just x'(n) 
  - Reducing higher derivatives to lower ones (cont. eq):
    D':=e -> y:=e, D'=y, and replace D' everywhere with y.
  - // anything else that came up from the recent paper?

Semantics (What we would like to have)
  - All discrete assignments should be done in paralell
    - Repeat until a fixed point is reached.
    - This should set higher derivatives to undefined [BUT NOT YET!]
    - Any duplicates are an error
  - All integations should be done in parallel [BUT NOT YET!]
    - Any duplicates are an error
    - Here we should (semantically) check there are no undefined
      variables.
  - "Purely continuous assignments" -> when should they be done?
    Adam tried out an implementation where they are all done before
    integrations.
  - Ad hoc choice:  All discrete, then all parallel.
  - Lets are always done afresh on any iterations
    - This should preserve the exact substitution property
